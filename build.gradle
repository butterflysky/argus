plugins {
    id 'base'
    id 'fabric-loom' version '1.13.3' apply false
    id 'org.jetbrains.kotlin.jvm' version '2.1.20' apply false
    id 'org.jetbrains.kotlin.plugin.serialization' version '2.1.20' apply false
    id 'com.diffplug.spotless' version '6.25.0' apply false
    id 'com.modrinth.minotaur' version '2.+' apply false
    id 'com.matthewprenger.cursegradle' version '1.4.0' apply false
    id 'idea'
    id 'eclipse'
}

ext {
    serializationVersion = "1.6.3"
    javacordVersion = project.findProperty("javacord_version") ?: "3.8.0"
    slf4jVersion = "2.0.13"
    junitVersion = project.findProperty("junit_version") ?: "5.11.0"

    def baseVersion = (project.findProperty("releaseVersion") ?: project.findProperty("mod_version") ?: "0.0.1").toString()
    def isReleaseBuild = project.hasProperty("releaseVersion")
    def resolveGitSha = {
        def envSha = System.getenv("GITHUB_SHA")
        if (envSha != null && !envSha.isBlank()) {
            return envSha.take(8)
        }
        try {
            def out = new ByteArrayOutputStream()
            project.exec {
                commandLine "git", "rev-parse", "--short=8", "HEAD"
                standardOutput = out
                errorOutput = new ByteArrayOutputStream()
                ignoreExitValue = true
            }
            def sha = out.toString().trim()
            return sha ? sha : "local"
        } catch (Exception ignored) {
            return "local"
        }
    }
    modVersionResolved = isReleaseBuild ? baseVersion : "${baseVersion}+git.${resolveGitSha()}"

    def targetList = (project.findProperty("mc_targets") ?: "1.21.10")
            .split(",")
            .collect { it.trim() }
            .findAll { it }
    if (targetList.isEmpty()) {
        throw new GradleException("mc_targets is empty; set it in gradle.properties")
    }

    def requiredKeys = [
            'minecraft_version',
            'yarn_mappings',
            'loader_version',
            'fabric_kotlin_version',
            'fabric_version',
            'neo_version'
    ]

    mcTargets = [:]
    targetList.each { target ->
        def prefix = "mc_${target.replace('.', '_')}_"
        def readProp = { key ->
            def value = project.findProperty("${prefix}${key}")
            return value != null ? value.toString() : null
        }

        def entry = [:]
        requiredKeys.each { key ->
            def value = readProp(key)
            if (!value) {
                throw new GradleException("Missing ${prefix}${key} in gradle.properties")
            }
            entry[key] = value
        }

        def parchmentMinecraft = readProp("parchment_minecraft")
        def parchmentMappings = readProp("parchment_mappings")
        if (parchmentMinecraft && parchmentMappings) {
            entry.parchment_minecraft = parchmentMinecraft
            entry.parchment_mappings = parchmentMappings
        }

        mcTargets[target] = entry
    }

    activeMcTarget = project.findProperty("mc_target") ?: targetList.last()
    activeVersions = mcTargets[activeMcTarget] ?: mcTargets.values().first()

    // Expose selected versions as project/ext props for downstream build scripts.
    def assignVersion = { key ->
        def value = project.findProperty(key) ?: activeVersions[key]
        ext[key] = value
    }
    [
            'minecraft_version',
            'yarn_mappings',
            'loader_version',
            'fabric_kotlin_version',
            'fabric_version',
            'neo_version',
            'parchment_minecraft',
            'parchment_mappings'
    ].each { assignVersion(it) }

    if (activeVersions.containsKey('parchment_minecraft') && activeVersions.containsKey('parchment_mappings')) {
        ext["neogradle.subsystems.parchment.minecraftVersion"] = ext.parchment_minecraft
        ext["neogradle.subsystems.parchment.mappingsVersion"] = ext.parchment_mappings
    }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'org.jetbrains.kotlin.jvm'
    apply plugin: 'org.jetbrains.kotlin.plugin.serialization'
    apply plugin: 'com.diffplug.spotless'
    apply plugin: 'jacoco'
    apply plugin: 'idea'
    apply plugin: 'eclipse'

    group = project.findProperty("maven_group") ?: "dev.butterflysky"
    version = rootProject.ext.modVersionResolved

    repositories {
        maven {
            name = 'Fabric'
            url = 'https://maven.fabricmc.net/'
        }
        mavenCentral()
    }

    java {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
        withSourcesJar()
    }

    tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
        kotlinOptions.jvmTarget = "21"
    }

    dependencies {
        testImplementation "org.jetbrains.kotlin:kotlin-test"
        testImplementation "org.junit.jupiter:junit-jupiter:${rootProject.ext.junitVersion}"
    }

    tasks.withType(Test).configureEach {
        useJUnitPlatform()
        finalizedBy(tasks.named("jacocoTestReport"))
    }

    jacoco {
        toolVersion = "0.8.12"
    }

    tasks.named("jacocoTestReport") {
        dependsOn(tasks.named("test"))
        reports {
            xml.required.set(true)
            html.required.set(true)
            csv.required.set(true)
        }
        classDirectories.setFrom(
            files(
                classDirectories.files.collect {
                    fileTree(it) {
                        exclude(
                            "**/DiscordBridge*",
                            "**/SmokeEntry*",
                        )
                    }
                },
            ),
        )
    }

    spotless {
        kotlin {
            ktlint("1.2.1")
            target("src/**/*.kt")
            trimTrailingWhitespace()
            endWithNewline()
        }
        kotlinGradle {
            ktlint("1.2.1")
            target("**/*.gradle.kts")
        }
    }

    // Place main jars under build/<project>/<mc_target> for clarity when switching targets
    tasks.withType(Jar).configureEach {
        if (project.name != "common" && name in ["jar", "remapJar"]) {
            destinationDirectory = layout.buildDirectory.dir("${project.name}/${rootProject.ext.activeMcTarget}")
            archiveClassifier = rootProject.ext.activeMcTarget
        }
    }
}

def sanitizeTarget = { target ->
    target.replaceAll(/[^0-9A-Za-z]+/, "_")
}

def registerMultiTarget = { baseName, gradleTasks, groupName ->
    def gradleWrapper = System.getProperty("os.name").toLowerCase().contains("windows") ? "gradlew.bat" : "./gradlew"
    def releaseVersionProp = project.hasProperty("releaseVersion") ? project.property("releaseVersion").toString() : null
    def perTargetTasks = mcTargets.keySet().collect { target ->
        tasks.register("${baseName}Mc_${sanitizeTarget(target)}", Exec) {
            group = groupName
            description = "${baseName} for Minecraft ${target}"
            workingDir = rootDir
            def args = [gradleWrapper] + gradleTasks + ["-Pmc_target=${target}"]
            if (releaseVersionProp) {
                args += "-PreleaseVersion=${releaseVersionProp}"
            }
            commandLine(args)
        }
    }
    tasks.register("${baseName}AllTargets") {
        group = groupName
        description = "${baseName} for all configured Minecraft targets"
        dependsOn(perTargetTasks)
    }
}

registerMultiTarget("build", ["build"], "build")
registerMultiTarget("check", ["check"], "verification")

tasks.register("printVersion") {
    group = "help"
    description = "Print the resolved Argus version and active Minecraft target."
    doLast {
        println("Argus version: ${rootProject.ext.modVersionResolved}")
        println("Minecraft target: ${rootProject.ext.minecraft_version}")
        println("mc_target: ${rootProject.ext.activeMcTarget}")
    }
}

configure(subprojects.findAll { it.name == "fabric" }) {
    apply plugin: 'fabric-loom'

    dependencies {
        minecraft "com.mojang:minecraft:${rootProject.ext.minecraft_version}"
        mappings "net.fabricmc:yarn:${rootProject.ext.yarn_mappings}:v2"
        modImplementation "net.fabricmc:fabric-loader:${rootProject.ext.loader_version}"
        modImplementation "net.fabricmc.fabric-api:fabric-api:${rootProject.ext.fabric_version}"
        modImplementation "net.fabricmc:fabric-language-kotlin:${rootProject.ext.fabric_kotlin_version}"
        implementation project(":common")
    }

    loom {
        splitEnvironmentSourceSets()
        decompilers {
            vineflower { }
        }
    }

    tasks.withType(JavaCompile).configureEach {
        options.release = 21
    }
}

project(":common") {
    dependencies {
        implementation "org.javacord:javacord:${rootProject.ext.javacordVersion}"
        implementation "org.jetbrains.kotlinx:kotlinx-serialization-json:${rootProject.ext.serializationVersion}"
    }
}

project(":neoforge") {
    // Placeholder: will add NeoForge specifics in a later task.
}

tasks.named("build") {
    dependsOn(subprojects.collect { it.tasks.named("build") })
}

tasks.named("check") {
    dependsOn("spotlessCheck", "fabricSmoke", ":fabric:fabricRunSmoke", ":fabric:fabricJarSmoke", "neoforgeJarSmoke", ":neoforge:neoforgeRunSmoke")
}

tasks.register("jacocoRootReport") {
    group = "verification"
    description = "Aggregate jacocoTestReport across all subprojects"
    dependsOn(subprojects.collect { it.tasks.matching { it.name == "jacocoTestReport" } })
}

def updateModVersion(String newVersion) {
    def propsFile = file("gradle.properties")
    if (!propsFile.exists()) {
        throw new GradleException("gradle.properties not found")
    }
    def content = propsFile.text
    def updated = content.replaceFirst(/(?m)^mod_version\\s*=.*/, "mod_version=${newVersion}")
    if (content == updated) {
        throw new GradleException("Failed to update mod_version in gradle.properties")
    }
    propsFile.text = updated
}

tasks.register("release") {
    group = "release"
    description = "Run tests/build, bump mod_version to -PreleaseVersion, commit, and tag."
    doFirst {
        if (!project.hasProperty("releaseVersion")) {
            throw new GradleException("Pass -PreleaseVersion=x.y.z")
        }
        def status = new ByteArrayOutputStream()
        exec {
            commandLine "git", "status", "--porcelain"
            standardOutput = status
        }
        if (status.toString().trim()) {
            throw new GradleException("Dirty worktree; please commit or stash before release.")
        }
    }
    dependsOn("buildAllTargets")
    doLast {
        def newVer = project.property("releaseVersion").toString()
        updateModVersion(newVer)
        exec { commandLine "git", "add", "gradle.properties" }
        exec { commandLine "git", "commit", "-m", "chore(release): v${newVer}" }
        exec { commandLine "git", "tag", "v${newVer}" }
        logger.lifecycle("Release v${newVer} created. Push with: git push && git push --tags")
    }
}

tasks.register("fabricSmokeAll") {
    group = "verification"
    description = "Run all Fabric smoke checks (metadata, jar load, headless run)"
    dependsOn("fabricSmoke", ":fabric:fabricJarSmoke", ":fabric:fabricRunSmoke")
}

tasks.register("neoforgeSmokeAll") {
    group = "verification"
    description = "Run all NeoForge smoke checks (metadata, jar load, headless run)"
    dependsOn("neoforgeJarSmoke", ":neoforge:neoforgeRunSmoke")
}

// --- Local dev scenarios (non-versioned, uses scratch/scenarios) ---
def scenarioDir = layout.projectDirectory.dir("scratch/scenarios")
def runDir = layout.projectDirectory.dir("fabric/run")

// Root-level spotless aggregators (subprojects own the real work)
tasks.register("spotlessCheck") {
    group = "verification"
    description = "Run spotlessCheck on all subprojects"
    dependsOn(subprojects.collect { it.tasks.matching { it.name == "spotlessCheck" } })
}
tasks.register("spotlessApply") {
    group = "verification"
    description = "Run spotlessApply on all subprojects"
    dependsOn(subprojects.collect { it.tasks.matching { it.name == "spotlessApply" } })
}

// Optional publishing stubs (activated only when tokens + project IDs are provided)
def modrinthToken = System.getenv("MODRINTH_TOKEN") ?: findProperty("modrinthToken")
def modrinthFabricId = System.getenv("MODRINTH_PROJECT_FABRIC") ?: findProperty("modrinthProjectFabric")
def modrinthNeoId = System.getenv("MODRINTH_PROJECT_NEOFORGE") ?: findProperty("modrinthProjectNeoforge")

def curseToken = System.getenv("CURSEFORGE_TOKEN") ?: findProperty("curseforgeToken")
def curseProjectId = System.getenv("CURSEFORGE_PROJECT_ID") ?: findProperty("curseforgeProjectId")

def gameVersions = [rootProject.ext.minecraft_version]

if (modrinthToken && modrinthFabricId) {
    project(":fabric").pluginManager.apply("com.modrinth.minotaur")
    project(":fabric").modrinth {
        token = modrinthToken
        projectId = modrinthFabricId
        versionNumber = "v${rootProject.version}-${rootProject.ext.minecraft_version}-fabric"
        versionName = "Argus ${rootProject.version} (Fabric ${rootProject.ext.minecraft_version})"
        loaders = ["fabric"]
        gameVersions = gameVersions
        uploadFile = project(":fabric").tasks.named("remapJar")
    }
    tasks.register("publishModrinthFabric") {
        group = "publishing"
        dependsOn(":fabric:modrinth")
    }
} else {
    tasks.register("publishModrinthFabric") {
        group = "publishing"
        doLast { logger.lifecycle("Modrinth Fabric publish skipped (set MODRINTH_TOKEN and MODRINTH_PROJECT_FABRIC to enable)") }
    }
}

if (modrinthToken && modrinthNeoId) {
    project(":neoforge").pluginManager.apply("com.modrinth.minotaur")
    project(":neoforge").modrinth {
        token = modrinthToken
        projectId = modrinthNeoId
        versionNumber = "v${rootProject.version}-${rootProject.ext.minecraft_version}-neoforge"
        versionName = "Argus ${rootProject.version} (NeoForge ${rootProject.ext.minecraft_version})"
        loaders = ["neoforge"]
        gameVersions = gameVersions
        uploadFile = project(":neoforge").tasks.named("jar")
    }
    tasks.register("publishModrinthNeoforge") {
        group = "publishing"
        dependsOn(":neoforge:modrinth")
    }
} else {
    tasks.register("publishModrinthNeoforge") {
        group = "publishing"
        doLast { logger.lifecycle("Modrinth NeoForge publish skipped (set MODRINTH_TOKEN and MODRINTH_PROJECT_NEOFORGE to enable)") }
    }
}

if (curseToken && curseProjectId) {
    project(":fabric").pluginManager.apply("com.matthewprenger.cursegradle")
    project(":neoforge").pluginManager.apply("com.matthewprenger.cursegradle")

    project(":fabric").curseforge {
        apiKey = curseToken
        project {
            id = curseProjectId
            releaseType = "release"
            addGameVersion(rootProject.ext.minecraft_version)
            addGameVersion("Fabric")
            mainArtifact(project(":fabric").tasks.named("remapJar"))
        }
    }
    project(":neoforge").curseforge {
        apiKey = curseToken
        project {
            id = curseProjectId
            releaseType = "release"
            addGameVersion(rootProject.ext.minecraft_version)
            addGameVersion("NeoForge")
            mainArtifact(project(":neoforge").tasks.named("jar"))
        }
    }

    tasks.register("publishCurseforge") {
        group = "publishing"
        dependsOn(":fabric:curseforge", ":neoforge:curseforge")
    }
} else {
    tasks.register("publishCurseforge") {
        group = "publishing"
        doLast { logger.lifecycle("CurseForge publish skipped (set CURSEFORGE_TOKEN and CURSEFORGE_PROJECT_ID to enable)") }
    }
}

[
        [task: "Correct", dir: "correct", desc: "Apply current known-good config/ops/whitelist to fabric/run"],
        [task: "WhitelistOff", dir: "whitelist_off", desc: "Whitelist disabled"],
        [task: "Misconfigured", dir: "misconfigured", desc: "Argus misconfigured (blank token/guild)"],
        [task: "LinkedWhitelisted", dir: "linked_whitelisted", desc: "Non-op linked + whitelisted with cache access"],
        [task: "LegacyUnlinked", dir: "legacy_unlinked", desc: "Legacy vanilla-whitelisted but unlinked"],
        [task: "Stranger", dir: "stranger", desc: "Stranger (no whitelist, no cache)"],
        [task: "OpOnly", dir: "op_only", desc: "OP only, no whitelist entries"]
].each { spec ->
    tasks.register("applyScenario${spec.task}", Copy) {
        group = "scenarios"
        description = spec.desc
        from(scenarioDir.dir(spec.dir)) {
            include("server.properties", "ops.json", "whitelist.json", "config/**")
        }
        into(runDir)
        duplicatesStrategy = DuplicatesStrategy.INCLUDE
    }
}

// --- Packaging smoke checks (headless) ---
tasks.register("fabricSmoke") {
    group = "verification"
    description = "Headless smoke: fabric jar contains metadata and entrypoints"
    def fabricProject = project(":fabric")
    def fabricJar = fabricProject.tasks.named("remapJar").flatMap { it.archiveFile }
    inputs.file(fabricJar)
    dependsOn(fabricProject.tasks.named("remapJar"))
    doLast {
        def jarFile = fabricJar.get().asFile
        def entries = zipTree(jarFile).files.collect { it.path.substring(it.path.indexOf("!") + 1) }
        assert entries.any { it.endsWith("fabric.mod.json") } : "fabric.mod.json missing in ${jarFile}"
        assert entries.any { it.contains("argus") } : "Argus classes missing in ${jarFile}"
    }
}

tasks.register("neoforgeJarSmoke") {
    group = "verification"
    description = "Headless smoke: neoforge jar contains metadata and classes"
    def neoProject = project(":neoforge")
    def neoJar = neoProject.tasks.named("jar").flatMap { it.archiveFile }
    inputs.file(neoJar)
    dependsOn(neoProject.tasks.named("jar"))
    doLast {
        def jarFile = neoJar.get().asFile
        def entries = zipTree(jarFile).files.collect { it.path.substring(it.path.indexOf("!") + 1) }
        assert entries.any { it.endsWith("META-INF/neoforge.mods.toml") } : "neoforge.mods.toml missing in ${jarFile}"
        assert entries.any { it.contains("argus") } : "Argus classes missing in ${jarFile}"
    }
}

// Fabric runtime smoke: start server headless, auto-stop; ensure EULA accepted
