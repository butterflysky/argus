plugins {
    id 'base'
    id 'fabric-loom' version '1.11-SNAPSHOT' apply false
    id 'org.jetbrains.kotlin.jvm' version '2.1.20' apply false
    id 'org.jetbrains.kotlin.plugin.serialization' version '2.1.20' apply false
    id 'com.diffplug.spotless' version '6.25.0' apply false
    id 'idea'
    id 'eclipse'
}

ext {
    serializationVersion = "1.6.3"
    javacordVersion = project.findProperty("javacord_version") ?: "3.8.0"
    slf4jVersion = "2.0.13"
    junitVersion = project.findProperty("junit_version") ?: "5.11.0"

    mcTargets = [
            "1.21.10": [
                    minecraft_version       : "1.21.10",
                    yarn_mappings           : "1.21.10+build.2",
                    loader_version          : "0.17.3",
                    fabric_kotlin_version   : "1.13.7+kotlin.2.2.21",
                    fabric_version          : "0.138.3+1.21.10",
                    neo_version             : "21.10.64",
                    parchment_minecraft     : "1.21.10",
                    parchment_mappings      : "2025.10.12"
            ]
    ]

    activeMcTarget = project.findProperty("mc_target") ?: "1.21.10"
    activeVersions = mcTargets[activeMcTarget] ?: mcTargets.values().first()

    // Expose selected versions as project/ext props for downstream build scripts.
    def assignVersion = { key ->
        def value = project.findProperty(key) ?: activeVersions[key]
        ext[key] = value
    }
    [
            'minecraft_version',
            'yarn_mappings',
            'loader_version',
            'fabric_kotlin_version',
            'fabric_version',
            'neo_version',
            'parchment_minecraft',
            'parchment_mappings'
    ].each { assignVersion(it) }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'org.jetbrains.kotlin.jvm'
    apply plugin: 'org.jetbrains.kotlin.plugin.serialization'
    apply plugin: 'com.diffplug.spotless'
    apply plugin: 'idea'
    apply plugin: 'eclipse'

    group = project.findProperty("maven_group") ?: "dev.butterflysky"
    version = project.findProperty("mod_version") ?: "0.0.1"

    repositories {
        maven {
            name = 'Fabric'
            url = 'https://maven.fabricmc.net/'
        }
        mavenCentral()
    }

    java {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
        withSourcesJar()
    }

    tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
        kotlinOptions.jvmTarget = "21"
    }

    spotless {
        kotlin {
            ktlint("1.2.1")
            target("src/**/*.kt")
            trimTrailingWhitespace()
            endWithNewline()
        }
        kotlinGradle {
            ktlint("1.2.1")
            target("**/*.gradle.kts")
        }
    }

    // Place main jars under build/<project>/<mc_target> for clarity when switching targets
    tasks.withType(Jar).configureEach {
        if (name in ["jar", "remapJar"]) {
            destinationDirectory = layout.buildDirectory.dir("${project.name}/${rootProject.ext.activeMcTarget}")
            archiveClassifier = rootProject.ext.activeMcTarget
        }
    }
}

configure(subprojects.findAll { it.name == "fabric" }) {
    apply plugin: 'fabric-loom'

    dependencies {
        minecraft "com.mojang:minecraft:${rootProject.ext.minecraft_version}"
        mappings "net.fabricmc:yarn:${rootProject.ext.yarn_mappings}:v2"
        modImplementation "net.fabricmc:fabric-loader:${rootProject.ext.loader_version}"
        modImplementation "net.fabricmc.fabric-api:fabric-api:${rootProject.ext.fabric_version}"
        modImplementation "net.fabricmc:fabric-language-kotlin:${rootProject.ext.fabric_kotlin_version}"
        implementation project(":common")
    }

    loom {
        splitEnvironmentSourceSets()
        decompilers {
            vineflower { }
        }
    }

    tasks.withType(JavaCompile).configureEach {
        options.release = 21
    }
}

project(":common") {
    dependencies {
        implementation "org.javacord:javacord:${rootProject.ext.javacordVersion}"
        implementation "org.jetbrains.kotlinx:kotlinx-serialization-json:${rootProject.ext.serializationVersion}"
    }
}

project(":neoforge") {
    // Placeholder: will add NeoForge specifics in a later task.
}

tasks.named("build") {
    dependsOn(subprojects.collect { it.tasks.named("build") })
}

tasks.named("check") {
    dependsOn("spotlessCheck", "fabricSmoke", "neoforgeSmoke")
}

// --- Local dev scenarios (non-versioned, uses scratch/scenarios) ---
def scenarioDir = layout.projectDirectory.dir("scratch/scenarios")
def runDir = layout.projectDirectory.dir("fabric/run")

// Root-level spotless aggregators (subprojects own the real work)
tasks.register("spotlessCheck") {
    group = "verification"
    description = "Run spotlessCheck on all subprojects"
    dependsOn(subprojects.collect { it.tasks.matching { it.name == "spotlessCheck" } })
}
tasks.register("spotlessApply") {
    group = "verification"
    description = "Run spotlessApply on all subprojects"
    dependsOn(subprojects.collect { it.tasks.matching { it.name == "spotlessApply" } })
}

[
        [task: "Correct", dir: "correct", desc: "Apply current known-good config/ops/whitelist to fabric/run"],
        [task: "WhitelistOff", dir: "whitelist_off", desc: "Whitelist disabled"],
        [task: "Misconfigured", dir: "misconfigured", desc: "Argus misconfigured (blank token/guild)"],
        [task: "LinkedWhitelisted", dir: "linked_whitelisted", desc: "Non-op linked + whitelisted with cache access"],
        [task: "LegacyUnlinked", dir: "legacy_unlinked", desc: "Legacy vanilla-whitelisted but unlinked"],
        [task: "Stranger", dir: "stranger", desc: "Stranger (no whitelist, no cache)"],
        [task: "OpOnly", dir: "op_only", desc: "OP only, no whitelist entries"]
].each { spec ->
    tasks.register("applyScenario${spec.task}", Copy) {
        group = "scenarios"
        description = spec.desc
        from(scenarioDir.dir(spec.dir)) {
            include("server.properties", "ops.json", "whitelist.json", "config/**")
        }
        into(runDir)
        duplicatesStrategy = DuplicatesStrategy.INCLUDE
    }
}

// --- Packaging smoke checks (headless) ---
tasks.register("fabricSmoke") {
    group = "verification"
    description = "Headless smoke: fabric jar contains metadata and entrypoints"
    def fabricProject = project(":fabric")
    def fabricJar = fabricProject.tasks.named("remapJar").flatMap { it.archiveFile }
    inputs.file(fabricJar)
    dependsOn(fabricProject.tasks.named("remapJar"))
    doLast {
        def jarFile = fabricJar.get().asFile
        def entries = zipTree(jarFile).files.collect { it.path.substring(it.path.indexOf("!") + 1) }
        assert entries.any { it.endsWith("fabric.mod.json") } : "fabric.mod.json missing in ${jarFile}"
        assert entries.any { it.contains("argus") } : "Argus classes missing in ${jarFile}"
    }
}

tasks.register("neoforgeSmoke") {
    group = "verification"
    description = "Headless smoke: neoforge jar contains metadata and classes"
    def neoProject = project(":neoforge")
    def neoJar = neoProject.tasks.named("jar").flatMap { it.archiveFile }
    inputs.file(neoJar)
    dependsOn(neoProject.tasks.named("jar"))
    doLast {
        def jarFile = neoJar.get().asFile
        def entries = zipTree(jarFile).files.collect { it.path.substring(it.path.indexOf("!") + 1) }
        assert entries.any { it.endsWith("META-INF/neoforge.mods.toml") } : "neoforge.mods.toml missing in ${jarFile}"
        assert entries.any { it.contains("argus") } : "Argus classes missing in ${jarFile}"
    }
}
