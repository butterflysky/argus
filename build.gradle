plugins {
    id 'base'
    id 'fabric-loom' version '1.11-SNAPSHOT' apply false
    id 'org.jetbrains.kotlin.jvm' version '2.1.20' apply false
    id 'org.jetbrains.kotlin.plugin.serialization' version '2.1.20' apply false
    id 'com.diffplug.spotless' version '6.25.0' apply false
    id 'com.modrinth.minotaur' version '2.+' apply false
    id 'com.matthewprenger.cursegradle' version '1.4.0' apply false
    id 'idea'
    id 'eclipse'
}

ext {
    serializationVersion = "1.6.3"
    javacordVersion = project.findProperty("javacord_version") ?: "3.8.0"
    slf4jVersion = "2.0.13"
    junitVersion = project.findProperty("junit_version") ?: "5.11.0"

    mcTargets = [
            "1.21.10": [
                    minecraft_version       : "1.21.10",
                    yarn_mappings           : "1.21.10+build.2",
                    loader_version          : "0.17.3",
                    fabric_kotlin_version   : "1.13.7+kotlin.2.2.21",
                    fabric_version          : "0.138.3+1.21.10",
                    neo_version             : "21.10.64",
                    parchment_minecraft     : "1.21.10",
                    parchment_mappings      : "2025.10.12"
            ]
    ]

    activeMcTarget = project.findProperty("mc_target") ?: "1.21.10"
    activeVersions = mcTargets[activeMcTarget] ?: mcTargets.values().first()

    // Expose selected versions as project/ext props for downstream build scripts.
    def assignVersion = { key ->
        def value = project.findProperty(key) ?: activeVersions[key]
        ext[key] = value
    }
    [
            'minecraft_version',
            'yarn_mappings',
            'loader_version',
            'fabric_kotlin_version',
            'fabric_version',
            'neo_version',
            'parchment_minecraft',
            'parchment_mappings'
    ].each { assignVersion(it) }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'org.jetbrains.kotlin.jvm'
    apply plugin: 'org.jetbrains.kotlin.plugin.serialization'
    apply plugin: 'com.diffplug.spotless'
    apply plugin: 'jacoco'
    apply plugin: 'idea'
    apply plugin: 'eclipse'

    group = project.findProperty("maven_group") ?: "dev.butterflysky"
    version = project.findProperty("mod_version") ?: "0.0.1"

    repositories {
        maven {
            name = 'Fabric'
            url = 'https://maven.fabricmc.net/'
        }
        mavenCentral()
    }

    java {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
        withSourcesJar()
    }

    tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
        kotlinOptions.jvmTarget = "21"
    }

    dependencies {
        testImplementation "org.jetbrains.kotlin:kotlin-test"
        testImplementation "org.junit.jupiter:junit-jupiter:${rootProject.ext.junitVersion}"
    }

    tasks.withType(Test).configureEach {
        useJUnitPlatform()
        finalizedBy(tasks.named("jacocoTestReport"))
    }

    jacoco {
        toolVersion = "0.8.12"
    }

    tasks.named("jacocoTestReport") {
        dependsOn(tasks.named("test"))
        reports {
            xml.required.set(true)
            html.required.set(true)
            csv.required.set(false)
        }
    }

    spotless {
        kotlin {
            ktlint("1.2.1")
            target("src/**/*.kt")
            trimTrailingWhitespace()
            endWithNewline()
        }
        kotlinGradle {
            ktlint("1.2.1")
            target("**/*.gradle.kts")
        }
    }

    // Place main jars under build/<project>/<mc_target> for clarity when switching targets
    tasks.withType(Jar).configureEach {
        if (project.name != "common" && name in ["jar", "remapJar"]) {
            destinationDirectory = layout.buildDirectory.dir("${project.name}/${rootProject.ext.activeMcTarget}")
            archiveClassifier = rootProject.ext.activeMcTarget
        }
    }
}

configure(subprojects.findAll { it.name == "fabric" }) {
    apply plugin: 'fabric-loom'

    dependencies {
        minecraft "com.mojang:minecraft:${rootProject.ext.minecraft_version}"
        mappings "net.fabricmc:yarn:${rootProject.ext.yarn_mappings}:v2"
        modImplementation "net.fabricmc:fabric-loader:${rootProject.ext.loader_version}"
        modImplementation "net.fabricmc.fabric-api:fabric-api:${rootProject.ext.fabric_version}"
        modImplementation "net.fabricmc:fabric-language-kotlin:${rootProject.ext.fabric_kotlin_version}"
        implementation project(":common")
    }

    loom {
        splitEnvironmentSourceSets()
        decompilers {
            vineflower { }
        }
    }

    tasks.withType(JavaCompile).configureEach {
        options.release = 21
    }
}

project(":common") {
    dependencies {
        implementation "org.javacord:javacord:${rootProject.ext.javacordVersion}"
        implementation "org.jetbrains.kotlinx:kotlinx-serialization-json:${rootProject.ext.serializationVersion}"
    }
}

project(":neoforge") {
    // Placeholder: will add NeoForge specifics in a later task.
}

tasks.named("build") {
    dependsOn(subprojects.collect { it.tasks.named("build") })
}

tasks.named("check") {
    dependsOn("spotlessCheck", "fabricSmoke", ":fabric:fabricRunSmoke", ":fabric:fabricJarSmoke", "neoforgeJarSmoke", ":neoforge:neoforgeRunSmoke")
}

tasks.register("jacocoRootReport") {
    group = "verification"
    description = "Aggregate jacocoTestReport across all subprojects"
    dependsOn(subprojects.collect { it.tasks.matching { it.name == "jacocoTestReport" } })
}

tasks.register("fabricSmokeAll") {
    group = "verification"
    description = "Run all Fabric smoke checks (metadata, jar load, headless run)"
    dependsOn("fabricSmoke", ":fabric:fabricJarSmoke", ":fabric:fabricRunSmoke")
}

tasks.register("neoforgeSmokeAll") {
    group = "verification"
    description = "Run all NeoForge smoke checks (metadata, jar load, headless run)"
    dependsOn("neoforgeJarSmoke", ":neoforge:neoforgeRunSmoke")
}

// --- Local dev scenarios (non-versioned, uses scratch/scenarios) ---
def scenarioDir = layout.projectDirectory.dir("scratch/scenarios")
def runDir = layout.projectDirectory.dir("fabric/run")

// Root-level spotless aggregators (subprojects own the real work)
tasks.register("spotlessCheck") {
    group = "verification"
    description = "Run spotlessCheck on all subprojects"
    dependsOn(subprojects.collect { it.tasks.matching { it.name == "spotlessCheck" } })
}
tasks.register("spotlessApply") {
    group = "verification"
    description = "Run spotlessApply on all subprojects"
    dependsOn(subprojects.collect { it.tasks.matching { it.name == "spotlessApply" } })
}

// Optional publishing stubs (activated only when tokens + project IDs are provided)
def modrinthToken = System.getenv("MODRINTH_TOKEN") ?: findProperty("modrinthToken")
def modrinthFabricId = System.getenv("MODRINTH_PROJECT_FABRIC") ?: findProperty("modrinthProjectFabric")
def modrinthNeoId = System.getenv("MODRINTH_PROJECT_NEOFORGE") ?: findProperty("modrinthProjectNeoforge")

def curseToken = System.getenv("CURSEFORGE_TOKEN") ?: findProperty("curseforgeToken")
def curseProjectId = System.getenv("CURSEFORGE_PROJECT_ID") ?: findProperty("curseforgeProjectId")

def gameVersions = [rootProject.ext.minecraft_version]

if (modrinthToken && modrinthFabricId) {
    project(":fabric").pluginManager.apply("com.modrinth.minotaur")
    project(":fabric").modrinth {
        token = modrinthToken
        projectId = modrinthFabricId
        versionNumber = "v${rootProject.version}-fabric"
        versionName = "Argus ${rootProject.version} (Fabric)"
        loaders = ["fabric"]
        gameVersions = gameVersions
        uploadFile = project(":fabric").tasks.named("remapJar")
    }
    tasks.register("publishModrinthFabric") {
        group = "publishing"
        dependsOn(":fabric:modrinth")
    }
} else {
    tasks.register("publishModrinthFabric") {
        group = "publishing"
        doLast { logger.lifecycle("Modrinth Fabric publish skipped (set MODRINTH_TOKEN and MODRINTH_PROJECT_FABRIC to enable)") }
    }
}

if (modrinthToken && modrinthNeoId) {
    project(":neoforge").pluginManager.apply("com.modrinth.minotaur")
    project(":neoforge").modrinth {
        token = modrinthToken
        projectId = modrinthNeoId
        versionNumber = "v${rootProject.version}-neoforge"
        versionName = "Argus ${rootProject.version} (NeoForge)"
        loaders = ["neoforge"]
        gameVersions = gameVersions
        uploadFile = project(":neoforge").tasks.named("jar")
    }
    tasks.register("publishModrinthNeoforge") {
        group = "publishing"
        dependsOn(":neoforge:modrinth")
    }
} else {
    tasks.register("publishModrinthNeoforge") {
        group = "publishing"
        doLast { logger.lifecycle("Modrinth NeoForge publish skipped (set MODRINTH_TOKEN and MODRINTH_PROJECT_NEOFORGE to enable)") }
    }
}

if (curseToken && curseProjectId) {
    project(":fabric").pluginManager.apply("com.matthewprenger.cursegradle")
    project(":neoforge").pluginManager.apply("com.matthewprenger.cursegradle")

    project(":fabric").curseforge {
        apiKey = curseToken
        project {
            id = curseProjectId
            releaseType = "release"
            addGameVersion(rootProject.ext.minecraft_version)
            addGameVersion("Fabric")
            mainArtifact(project(":fabric").tasks.named("remapJar"))
        }
    }
    project(":neoforge").curseforge {
        apiKey = curseToken
        project {
            id = curseProjectId
            releaseType = "release"
            addGameVersion(rootProject.ext.minecraft_version)
            addGameVersion("NeoForge")
            mainArtifact(project(":neoforge").tasks.named("jar"))
        }
    }

    tasks.register("publishCurseforge") {
        group = "publishing"
        dependsOn(":fabric:curseforge", ":neoforge:curseforge")
    }
} else {
    tasks.register("publishCurseforge") {
        group = "publishing"
        doLast { logger.lifecycle("CurseForge publish skipped (set CURSEFORGE_TOKEN and CURSEFORGE_PROJECT_ID to enable)") }
    }
}

[
        [task: "Correct", dir: "correct", desc: "Apply current known-good config/ops/whitelist to fabric/run"],
        [task: "WhitelistOff", dir: "whitelist_off", desc: "Whitelist disabled"],
        [task: "Misconfigured", dir: "misconfigured", desc: "Argus misconfigured (blank token/guild)"],
        [task: "LinkedWhitelisted", dir: "linked_whitelisted", desc: "Non-op linked + whitelisted with cache access"],
        [task: "LegacyUnlinked", dir: "legacy_unlinked", desc: "Legacy vanilla-whitelisted but unlinked"],
        [task: "Stranger", dir: "stranger", desc: "Stranger (no whitelist, no cache)"],
        [task: "OpOnly", dir: "op_only", desc: "OP only, no whitelist entries"]
].each { spec ->
    tasks.register("applyScenario${spec.task}", Copy) {
        group = "scenarios"
        description = spec.desc
        from(scenarioDir.dir(spec.dir)) {
            include("server.properties", "ops.json", "whitelist.json", "config/**")
        }
        into(runDir)
        duplicatesStrategy = DuplicatesStrategy.INCLUDE
    }
}

// --- Packaging smoke checks (headless) ---
tasks.register("fabricSmoke") {
    group = "verification"
    description = "Headless smoke: fabric jar contains metadata and entrypoints"
    def fabricProject = project(":fabric")
    def fabricJar = fabricProject.tasks.named("remapJar").flatMap { it.archiveFile }
    inputs.file(fabricJar)
    dependsOn(fabricProject.tasks.named("remapJar"))
    doLast {
        def jarFile = fabricJar.get().asFile
        def entries = zipTree(jarFile).files.collect { it.path.substring(it.path.indexOf("!") + 1) }
        assert entries.any { it.endsWith("fabric.mod.json") } : "fabric.mod.json missing in ${jarFile}"
        assert entries.any { it.contains("argus") } : "Argus classes missing in ${jarFile}"
    }
}

tasks.register("neoforgeJarSmoke") {
    group = "verification"
    description = "Headless smoke: neoforge jar contains metadata and classes"
    def neoProject = project(":neoforge")
    def neoJar = neoProject.tasks.named("jar").flatMap { it.archiveFile }
    inputs.file(neoJar)
    dependsOn(neoProject.tasks.named("jar"))
    doLast {
        def jarFile = neoJar.get().asFile
        def entries = zipTree(jarFile).files.collect { it.path.substring(it.path.indexOf("!") + 1) }
        assert entries.any { it.endsWith("META-INF/neoforge.mods.toml") } : "neoforge.mods.toml missing in ${jarFile}"
        assert entries.any { it.contains("argus") } : "Argus classes missing in ${jarFile}"
    }
}

// Fabric runtime smoke: start server headless, auto-stop; ensure EULA accepted
